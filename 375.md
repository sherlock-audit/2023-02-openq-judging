CodeFoxInc

high

# Overflow attack in function `claimTieredPercentageBounty`

## Summary
Overflow attack is possible to be conducted in `_claimTieredPercentageBounty` function. 

## Vulnerability Detail
I will put an example of attacking the protocol below to show what is the vulnerability is. 

### prerequisite
Especially I want to talk about the condition of `TieredPercentageBountyV1.sol`. 
- According to the code in the repo, although whitelist exists, 
  - still anyone can funds the bounty. 
  - The token can be any kind of ERC20 token including a customized ERC20 token. 
  - The only condition required is the token addresses limit is not reached. 
(related code is shown here: [DepositManagerV1.sol#L45-L50](https://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/DepositManager/Implementations/DepositManagerV1.sol#L36-L74))
```solidity
if (!isWhitelisted(_tokenAddress)) { 
     require( 
         !tokenAddressLimitReached(_bountyAddress), 
         Errors.TOO_MANY_TOKEN_ADDRESSES 
     ); 
 } 
```


### Attacking Process
1. The attacker first deploys a customized ERC20 token, and then he can mint a maximum amount of token, e.g. `type(uint256).max`. 
2. Then the attacker can fund any bounty as long as the token addresses limit is not reached, using the customized token to deposit a large amount of token, e.g. `type(uint256).max`. (The related code: [DepositManagerV1.sol#L36-L74](../blob/main/contracts/DepositManager/Implementations/DepositManagerV1.sol#L36-L74))
3. The attacking process of the attacker is done at this moment. 
- After a while when someone wants to claim the token this happens: 
  - When someone tries to claim the bounty, the function `claimTiered ` is called and it will loop through all the tokens to claim the bounty of the attacker. (related code: [ClaimManagerV1.sol#L230-L235](../blob/main/contracts/ClaimManager/Implementations/ClaimManagerV1.sol#L230-L235) 
  - When the loop goes to the malicious customized ERC20 token, during the calculation of the claimable amount the overflow occurs and the transaction will revert. (related code: [TieredPercentageBountyV1.sol#L115-L116](../blob/main/contracts/Bounty/Implementations/TieredPercentageBountyV1.sol#L115-L116))

## Impact
This prevents the winner of the tier from getting proper funding. 
Malicious player can deposit customized ERC20 token to deny the winner's bounty, making nobody can claim the bounty. As such the protocol's service can be broken and denied by any malicious attacker. 


## Code Snippet
https://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/TieredPercentageBountyV1.sol#L115-L116

## Tool used

Manual Review + hardhat script

## Recommendation
We recommend use the whitelist to limit the tokens can be used in the protocol. As a result of this, no one can use his randomly created malicious token to break the protocol. 
And in our honest opinion, generally speaking people want to only get paid in several trusted tokens. Using random tokens can increase the exposure of risks to users and making the protocol too complex to be trusted. 

```solidity
if (!isWhitelisted(_tokenAddress)) { 
  revert("Token isn't whitelisted");
 } 
```
