ctf_sec

high

# User can fund ERC721 as ERC20 to block developer’s bounty withdraw in TieredPercetange Bounty

## Summary

User can fund ERC721 as ERC20 to block developer’s bounty withdraw in TieredPercetange Bounty

## Vulnerability Detail

The expectation is that the user should fund the ERC20 token using the fundBountyToken, for this reason, the bountyAddress is expected to be a ERC20 token, however, a malicious user can fund a ERC721 token using fundBountyToken

```solidity
function fundBountyToken(
    address _bountyAddress,
    address _tokenAddress,
    uint256 _volume,
    uint256 _expiration,
    string memory funderUuid
) external payable onlyProxy {
    IBounty bounty = IBounty(payable(_bountyAddress));

    if (!isWhitelisted(_tokenAddress)) {
        require(
            !tokenAddressLimitReached(_bountyAddress),
            Errors.TOO_MANY_TOKEN_ADDRESSES
        );
    }

    require(bountyIsOpen(_bountyAddress), Errors.CONTRACT_ALREADY_CLOSED);

    (bytes32 depositId, uint256 volumeReceived) = bounty.receiveFunds{
        value: msg.value
    }(msg.sender, _tokenAddress, _volume, _expiration);
```

If the bountyAddress, the transfer still go through, the impact is severe:

```solidity
function receiveFunds(
      address _funder,
      address _tokenAddress,
      uint256 _volume,
      uint256 _expiration
  )
      external
      payable
      virtual
      onlyDepositManager
      nonReentrant
      returns (bytes32, uint256)
  {
      require(_volume != 0, Errors.ZERO_VOLUME_SENT);
      require(_expiration > 0, Errors.EXPIRATION_NOT_GREATER_THAN_ZERO);
      require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);

      bytes32 depositId = _generateDepositId();

      uint256 volumeReceived;
      if (_tokenAddress == address(0)) {
          volumeReceived = msg.value;
      } else {
          volumeReceived = _receiveERC20(_tokenAddress, _funder, _volume);
      }

      funder[depositId] = _funder;
      tokenAddress[depositId] = _tokenAddress;
      volume[depositId] = volumeReceived;
      depositTime[depositId] = block.timestamp;
      expiration[depositId] = _expiration;
      isNFT[depositId] = false;

      deposits.push(depositId);
      tokenAddresses.add(_tokenAddress);

      return (depositId, volumeReceived);
  }

```

note the code:

```solidity
deposits.push(depositId);
tokenAddresses.add(_tokenAddress);
```

When claiming the atomic bounty, the code executes:

```solidity
function _claimAtomicBounty(
  IAtomicBounty _bounty,
  address _closer,
  bytes calldata _closerData
) internal {
  _eligibleToClaimAtomicBounty(_bounty, _closer);

  for (uint256 i = 0; i < _bounty.getTokenAddresses().length; i++) {
      uint256 volume = _bounty.claimBalance(
          _closer,
          _bounty.getTokenAddresses()[i]
      );
```

Which calls:

```solidity
/// @notice Transfers full balance of _tokenAddress from bounty to _payoutAddress
/// @param _tokenAddress ERC20 token address or Zero Address for protocol token
/// @param _payoutAddress The destination address for the funds
function claimBalance(address _payoutAddress, address _tokenAddress)
    external
    onlyClaimManager
    nonReentrant
    returns (uint256)
{
    uint256 claimedBalance = getTokenBalance(_tokenAddress);
    _transferToken(_tokenAddress, claimedBalance, _payoutAddress);
    return claimedBalance;
}
```

which calls:

```solidity
/// @notice Transfers _volume of both ERC20 or protocol token to _payoutAddress
/// @param _tokenAddress Address of an ERC20 or Zero Address for protocol token
/// @param _volume Volume to transfer
/// @param _payoutAddress Destination address
function _transferToken(
    address _tokenAddress,
    uint256 _volume,
    address _payoutAddress
) internal virtual {
    if (_tokenAddress == address(0)) {
        _transferProtocolToken(_payoutAddress, _volume);
    } else {
        _transferERC20(_tokenAddress, _payoutAddress, _volume);
    }
}
```

For example, the user supplies as ERC721 id 1034 into the bounty contract, but the getTokenBalance(_tokenAddress) would return 1 because the contract hold 1 NFT,

and the transaction revert in _transferToken(_tokenAddress, claimedBalance, _payoutAddress) because eventually the code _transferERC20(_tokenAddress, _payoutAddress, _volume) is called,

volume is 1, but the bounty contract does not hold NFT ID 1.

Same issue exists if the user uses the ERC721 token to fund the TieredPercentage contract:

```solidity
function claimTiered(
    address _payoutAddress,
    uint256 _tier,
    address _tokenAddress
) external onlyClaimManager nonReentrant returns (uint256) {
    require(
        bountyType == OpenQDefinitions.TIERED_PERCENTAGE,
        Errors.NOT_A_TIERED_BOUNTY
    );
    require(!tierClaimed[_tier], Errors.TIER_ALREADY_CLAIMED);

    uint256 claimedBalance = (payoutSchedule[_tier] *
        fundingTotals[_tokenAddress]) / 100;

    _transferToken(_tokenAddress, claimedBalance, _payoutAddress);
    return claimedBalance;
}
```

It would be difficult to make 

```solidity
 uint256 claimedBalance = (payoutSchedule[_tier] *
        fundingTotals[_tokenAddress]) / 100;
```

Match the token ID hold in the bounty contract, and _transferToken(_tokenAddress, claimedBalance, _payoutAddress) revert because the claimedBalance does not match the supplies ERC721 token id easily.

## Impact

User can fund ERC721 as ERC20 to block developer’s bounty withdraw in TieredPercetange Bounty

## Code Snippet

https://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/DepositManager/Implementations/DepositManagerV1.sol#L29-L75

## Tool used

Manual Review

## Recommendation

Create a whitelist for ERC20 token and create a whitelist for ERC721 token and that validates the token address is in the whitelist before letting the user supplies the token to fund the bounty contract.